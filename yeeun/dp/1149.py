# https://www.acmicpc.net/problem/1149
# RGB거리
'''
RGB거리에는 집이 N개 있다.거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때,
규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값
* rules
1번 집의 색은 2번 집의 색과 같지 않아야 한다.
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

1 2 3
R G R 가능

'''

#전략
'''
dp : 큰 문제 -> 작은 문제

집 n n+1 n+2 가 있다고 했을 때
n+1의 색 정하고 -> n 색 정하기

dp[n+1][0] : n+1집이 0번째 색을 선택한 상태에 있을 때의 n ~ n+1 번 째 집의 색칠 최솟값

1. dp[n+1][0] : n+1번째 집이 0번째 색을 칠하는 값 + n 번째 집이 1 또는 2 색 중 더 적은 값으로 칠하는 값
2. dp[n+1][0] = dp[n+1][0] + min(dp[n][1], dp[n][2])
이런 식으로 채워간다면 dp[i] = i번째 집이 0번1번2번 색을 칠하길 선택했을 때 각각의 누적 색칠값 리스트가 될 것이다.
따라서 min(dp[i]) 을 해준다면 총 가구의 색칠 최솟값이 출력될 것이다.

주의할 점은 맨 처음 집부터 비용 최솟값을 선택하는 게 아니라 2번째 집의 선택에 따라 1번째 집의 칠값 최솟값을 따진다는 것이다.

'''

n = int(input())
dp = [
    list(map(int, input().split()))
    for _ in range(n)
]

for i in range(1, n):
    #i번째 집이 R로 칠하는 선택 시, i번째 집을 칠하는 것 까지의 비용의 최솟값
    dp[i][0] = dp[i][0] + min(dp[i-1][1], dp[i-1][2])
    #i번째 집이 G로 칠하는 선택 시, i번째 집을 칠하는 것 까지의 비용의 최솟값
    dp[i][1] = dp[i][1] + min(dp[i - 1][0], dp[i - 1][2])
    # i번째 집이 B로 칠하는 선택 시, i번째 집을 칠하는 것 까지의 비용의 최솟값
    dp[i][2] = dp[i][2] + min(dp[i - 1][0], dp[i - 1][1])
print(min(dp[n-1]))