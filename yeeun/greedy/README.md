# GREEDY

<이것이 취업을 위한 코딩테스트다 with 파이썬>을 토대로 작성하였습니다.

- 눈 앞의 선택에서 최적의 상황만 탐하는 방법. 최종 결과가 최적의 해가 될 순 없다. -> 탐욕법으로 얻은 해가 최적의 해가 되는 상황을 추론할 수 있어야 풀리도록 출제됨

## 대표문제

📂거스름 돈 문제

- 큰 단위의 화폐부터 거슬러주는 것이 왜 최적의 해를 보장하는 것인가? <br> 가지고 있는 동전 중 가장 큰 단위가 항상 작은 단위의 배수이므로. <br>
  -> 800원 거슬러 줘야하는 상황. 큰 단위가 작은 단위의 배수가 아닐 때) 단위가 500 / 400 / 100원이라면 400\*2 가 최적의 해가 됨

  <details>
  <summary>유형 문제</summary> </br>
  <div markdown="1">
    11047
  </div>
  </details>
  </br>

📂보석으로 배낭 채우기

- 보석을 쪼갤 수 없음. 보석을 담거나 담지 않거나 두 가지 선택지 밖에 없음
  -> 0/1 knapsack (DP로 풀어야 함)
- 보석을 쪼갤 수 있음. -> Fractional knapsack

  ```
  무게 대비 가격이 높은 보석을 우선적으로 담기. 가격/무게 값이 큰 보석 부터 담기.
  가격/무게 값으로 내림차순 정렬 -> 배낭 크기 넘지 않는 선에서 순서대로 보석 담기

  * 가치/무게 내림차순 정렬
    jewels.sort(key=lambda x: -x[1]/x[0])
  ```

📂숫자 합치기

- 숫자를 합쳐 하나의 숫자로 만드는 데 필요한 최소 비용 출력하기
- 2개의 숫자를 골라 합치는 과정을 하나의 숫자만 남을 때까지 반복
- 숫자 a,b를 합치는데 드는 비용은 a+b </br>
  ex) `[1, 3, 8, 10]` : 1+3 / 4+8 / 12+10 -> 비용 : 4 + 12 + 22 </br>
  ex) `[50, 50, 50, 50]` : </br>

  - 왼쪽부터 차례대로 더할 경우) 50+50 / 100+50/ 150+50 -> 비용: 100 + 150 + 200 = 450
  - 50,50끼리 2쌍을 만들어 각각 더한 뒤 합할 경우) 50+50, 50+50/ 100+100 -> 비용: 100+ 100 + 200 = 400

  ```
  순서와 상관 없이 "가장 작은 2개의 숫자만" 선택하는 그리디로 풀 수 있음
  유사 알고리즘 : 허프만 코드

  ```

  <details>
  <summary>유형 문제</summary> </br>
  <div markdown="1">
    11399.py
  </div>
  </details>
  </br>
  </br>

### input 속도 문제 해결

```
import sys
input = sys.stdin.readline
```

### Min size

```
import sys
INT_MIN = -sys.maxsize
```

### 실수표기

```
print(f"{result:.4f}")
```

### 수열의 합

```
1 + 1+2 + 1+2+3 + ...
for i in range(n):
    for j in range(i+1):
        print(i, j)

```

<details>
<summary>for루프</summary> </br>
<div markdown="1">
  ```
  for i in range(n): 
    for j in range(i+1):
        print(i, j)
  0 0
  1 0
  1 1
  2 0
  2 1
  2 2
  3 0
  3 1
  3 2
  3 3
  4 0
  4 1
  4 2
  4 3
  4 4
```
</div>
</details>
